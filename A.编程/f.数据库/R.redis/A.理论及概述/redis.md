# 1.数据结构与对象

## 1.1 简单动态字符串 SDS

### 1.1.1 概述

SDS( simple dynamic string,SDS )



### 1.1.2  作用

- 保存数据库中的字符串值
- 用作缓存区（buffer）:AOF模块中的AOF缓存区，以及客户端状态中的输入缓冲区，



### 1.1.3 定义

```c
struct sdshdr {
    
    //记录buf数组中已使用字节的数量，等于SDS所保存字符串的长度
    int len;
    
    //字节数组，用于保存字符串
    char buf[];
    
    
    
}
```



### 1.1.4 特性

- 自动插入字符数组末尾插入‘\0’ 字符，不占用 len。
- 不以 ‘\0’ 作为结束标志。
- 动态分配字节数组的大小.
- 预分配空间，既分配空间时会多分配空闲空间。
- 惰性空间释放, 既一般通过减少 len的大小 ，达到释放空间的目的，在需要时才会真实的释放空间。
- 兼容部分 C 语言字符串的函数







## 1.2  链表

### 1.2.1 概述

​	链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过赠删节点来灵活地调整链表的长度。



### 1.2.2 作用

- ​	列表的底层实现之一就是链表:

  ​             当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，redis就会使用链表作为列表键的底层实现

- 发布订阅

- 慢查询

- 监视器

- redis用链表来构建客户端输出缓冲区（output buffer ）



### 1.2.3 实现

```c
typedef struct listNode{
    //前置节点
    struct listNode *prev;
    
    //后置节点
    struct listNode *next;
    
    //节点的值
    void  * value;
    
}listNode;
```

```c
typedef struct list{
    //表头节点
    listNode *head;
    
    //后置节点
    listNode *tail;
    
    //链表所包含的节点数量
    unsigned long len;
    
    //节点值赋值函数
    void *(*dup)(void *ptr);
    
    //节点值释放函数
    void *(*free)(void *ptr);
    
    //节点值对比函数
    int  (*match)(void *ptr,void *key);
    
}list;
```

虽然仅仅使用多个listNode结构就可以组成链表，但使用list来持有链表，操作会更方便。

### 1.2.4 特性

- 双端
- 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。
- 可直接操作表头指针
- 可直接操作表尾指针
- 带链表长度计数器
- 多态：链表节点使用 void* 指针来保存节点值，并且可以通过list结构的 dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。







## 1.3 字典

### 1.3.1 概述

字典，又称为符号表（symbol table）、关联数组 （ associative array ）或映射（map）, 是一种用于保存键值对（key-value pair）的抽象数据结构。



哈希节点：键值对

哈希表：数组+链表  

字典：对哈希表进一步封装



### 1.3.2  作用

- **Redis的数据库就是使用字典来作为底层实现的**：对数据库的增、删、查、改操作也是构建在对字典的操作之上的，简单的说保存在redis的数据是以键值对的形式保存在名为“数据库”的字典里。
- **字典还是哈希键的底层实现之一**：当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现。



### 1.3.3 实现



![image-20200717223709385](img/image-20200717223709385.png)



哈希表

```c
typedef struct dictht{
    
    //哈希表数组
    dictEnty **table;
    
    //哈希表大小
    unsigned long size;
    
    //哈希表大小掩码，用于计算索引值 总是等于 size-1
    unsigned long sizemask;
    
    //该哈希表已有节点的数量
    unsigned long used;
    
}dictht;
```



table 属性是一个数组，数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针，每个dictEntry结构保存着一个键值对。



哈希表节点

```c
typedef struct dictEntry{
    
    //键
    void *key;
    
    //值
    union{
        void *val;
        uint64_tu64;
        int64_ts64;
    }v;
    
    //指向下个哈希表节点，形成链表
    struct dictEntry *next;
     
}dictEntry;
```



v属性保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数

next 属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，以此来解决键冲突（collision）的问题。



字典

```c
typedef struct dict{
    
    //类型特定函数
    dictType *type;
    
    //私有数据
    void *privdata;
    
    //哈希表
    dictht ht[2];
    
    //索引  当rehash 不在进行时，值为-1
    int rehashidx;
    
}dict;
```



type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的：

​		type 属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis 会为用途不同的字典设置不同的类型特定函数。

​		privdata属性则保存了需要传给哪些类型特定函数的可选参数。



```c
typedef struct dictType {
    
    //计算哈希值的函数
    unsigned  int (*hashFunction)(const void *key);
    
    //复制键的函数
    void *(keyDup)(void *privdata,const void *key);
    
    //复制值的函数
    void *(*valDup)(void *privdata,const void *obj);
    
    //对比键的函数
    int (*keyCompare)(void *privdata,const void *key1,const void *key2);
    
    //销毁键的函数
    void (*keyDestructor)(void *privdata,void *key);
    
    //销毁值的函数
    void (*valDestructor)(void *privdata,void *obj);
         
}dictType;
```



ht属性： ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会对ht[0]哈希表进行rehash时使用



rehash属性： 它记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为 -1。





### 1.3.4 rehash

为了让哈希表的负载因子（load factor） 维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。



扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成，Redis对字典的哈希表执行rehash的步骤如下：



#### 1.3.4.1 rehash步骤

1.  为字典的 ht[1] 哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是 ht[0].used属性的值）
   -   如果扩展，ht[1] 的大小为第一个大于等于ht[0].used*2 的2^n （2的n次方幂（mi））
   -   如果收缩，ht[1] 的大小为第一个小于等于ht[0].used的2^n.
2. 将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。
3. 当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0],将ht[1]设置为ht[0],并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。



#### 1.3.4.2 rehash触发条件

当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：

1. 服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于 1。
2. 服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于 5。

负载因子计算方式：

​	load_factor = ht[0].used / ht[0].size;



根据 BGSAVE 命令或 BGREWRITEAOF 命令是否正在执行，服务器执行扩展操作所需的负载因子并不相同，这是因为在执行 BGSAVE 命令或者 BGREWRITEAOF 命令的过程中，Redis 需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（ copy-on-write）技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。



另一方面，当哈希表的负载因子小于 0.1 时，程序自动开始对哈希表执行收缩操作。



####  1.3.4.3 渐进式rehash

扩展或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1]里面，但是，这个rehash动作并不是一次性完成的，而是分多次、渐进式地完成的。







## 1.4 跳跃表

有点难理解 ， 需要有懂的人，给予讲解



![image-20200720001135838](img/image-20200720001135838.png)



### 1.4.1  概述

跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。



跳跃表支持平均 O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。



在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。



### 1.4.2   作用

- 有序集合键的底层实现之一：如果一个有序集包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串时，Redis 就会使用跳跃表来作为有序集合键的底层实现。
- Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外，跳表在Redis里面没有其他用途。



### 1.4.3 实现

 Redis的跳跃表由 redis.h/zskiplistNode 和 redis.h/zskiplist 两个结构定义。

zskiplistNode 结构用于表示跳跃节点

zskiplist 结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表位节点的指针等等。



![image-20200720001408775](img/image-20200720001408775.png)



#### 1.4.3.1***跳跃表节点***

```c
typedef struct zskiplistNode {
    
    //层
    struct  zskiplistLevel{
        
        //前进指针
        struct  zskiplistNode *forward;
        
        //跨度
        unsigned int span;
        
	}level[];
    
    //后退指针
    struct zskiplistNode *backward;
    
    //分值
    double  score;
    
    //成员对象
    robj *obj;
    
}zskiplistNode;
```

**1.层**

跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。

每次创建一个新跳跃表节点的时候，程序都根据幂次定律（power law  ,越大的数出现的概率越小）随机生成一个介于1和32之间的值做为level数组的大小，这个大小就是层的“高度”。



**2.前进节点**

每个层都有一个指向表尾方向的前进指针（level[i].forward 属性），用于从表头向表尾方向访问节点。



**3.跨度**

层的跨度（level[i].span 属性）用于记录两个节点之间的距离：

- 两个节点之间的跨度越大，它们相距得就越远。
- 指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。



遍历操作只使用前进指针就可以完成，跨度实际上是用来计算排位（rank）的：

​	在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的

​    排位



**4.后退指针**

节点的后退指针（backwards ）用于表尾向表头方向访问节点：	

​	跟一次可以跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点





**5.分值和成员**

节点的分值（score）是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。



节点的成员对象（obj属性）是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值，



在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：

​	分值相同的节点将按照成员对象在字典序中的大小来进行排序，成员对象较小的节点会排在前面（靠近表头的的方向），而成员对象较大的节点则会排在后面（靠近表尾的方向）。



#### 1.4.3.2***跳跃表***

仅靠多个跳跃表节点就可以组成一个跳跃表

但通过一个zskiplist结构来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或者快速地获取跳跃表节点的数量（也既是跳跃表的长度）等信息。

```c
typedef struct zskiplist{
    
    //表头节点和表尾节点
    struct skiplistNode *header,*tail;
    
    //表中节点的数量
    unsigned long length;
    
    //表中层数最大的节点的层数
    int level;
    
}zskiplist;
```



header 指向跳跃表的表头

tail 指向表尾节点

length 记录节点的数量

level 属性则用于在O(1)复杂度内获取跳跃表中层高最大的那个节点的层数量，注意表头的层高并不计算在内。







## 1.5 整数集合

### 1.5.1概述

​	整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。



### 1.5.2 作用

- ​	整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。



### 1.5.3 实现

```c
typedef struct intset{

	//编码方式
	uint32_t encoding;
	
	//集合包含的元素数量
	uint32_t length;
	
	//保存元素的数组
	int8_t contents[];

}intset;
```



contents[ ]  数组是整数集合的底层实现： 整数集合的每个元素都是 contents数组的一个数组项（item）,各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项，存储内容的格式取决于 encoding。



length 属性记录了整数集合包含的元素数量，也即是 contents[] 数组的长度.



### 1.5.4 升级

 每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（ upgrade ）,然后才能将新元素添加到整数集合里面。





#### 1.5.4.1 步骤

- 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。
- 将底层数组现有的所有元素都转换成与新元类型相同类型，转换过程中有序性不变。
- 将新元素添加到底层数组里面。



#### 1.5.4.2 升级的好处  

1. 提升整数集合的灵活性：可以任意添加任何编码的整数 int_8  int_16  int_32  int_64。
2. 尽可能地节约内存。



### 1.5.5 降级

整数集合不支持降级操作



## 1.6 压缩列表

### 1.6.1概述

压缩列表 （ziplist）是列表键和哈希键的底层实现之一。



### 1.6.2 作用

- 列表键的底层实现之一：当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。
- 哈希键的底层实现之一：当一个哈希键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。



### 1.6.3 实现

压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。

一个压缩列表可以包含任意多个节点（entry）,每个节点可以保存一个字节数组或者一个整数值。



#### 1.6.3.1 压缩列表的构成

| 属性    | 类型     | 长度  | 用途                                                         |
| ------- | -------- | ----- | ------------------------------------------------------------ |
| zlbytes | uint32_t | 4字节 | 记录整个压缩列表占用的内存字节数; 在对压缩列表进行内存重分配，或者计算 zlend 的位置时使用 |
| zltail  | uint32_t | 4字节 | 记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址 |
| zllen   | uint16_t | 2字节 | 记录了压缩列表包含的节点数量：当这个属性的值小于UINT16_MAX（65535）时，这个属性的值就是压缩列表包含节点的数量：当这个值等于 UINT16_MAX时，节点的真实数量需要遍历整个压缩列表才能计算得出 |
| extryX  | 列表节点 | 不定  | 压缩列表包含的各个节点，节点的长度由节点保存的内容决定       |
| zlend   | uint8_t  | 1字节 | 特殊值 0xFF （十进制255)，用于标记压缩列表的末端             |



#### 1.6.3.2 压缩列表节点的构成

每个压缩列表节点可以保存一个字节数组或者一个整数值。



#### 1.6.3.3 连锁更新操作

添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率不高



