# 1.数据结构与对象

## 1.1 简单动态字符串 SDS

### 1.1.1 概述

SDS( simple dynamic string,SDS )



### 1.1.2  作用

- 保存数据库中的字符串值
- 用作缓存区（buffer）:AOF模块中的AOF缓存区，以及客户端状态中的输入缓冲区，



### 1.1.3 定义

```c
struct sdshdr {
    
    //记录buf数组中已使用字节的数量，等于SDS所保存字符串的长度
    int len;
    
    //字节数组，用于保存字符串
    char buf[];
    
    
    
}
```



### 1.1.4 特性

- 自动插入字符数组末尾插入‘\0’ 字符，不占用 len。
- 不以 ‘\0’ 作为结束标志。
- 动态分配字节数组的大小.
- 预分配空间，既分配空间时会多分配空闲空间。
- 惰性空间释放, 既一般通过减少 len的大小 ，达到释放空间的目的，在需要时才会真实的释放空间。
- 兼容部分 C 语言字符串的函数







## 1.2  链表

### 1.2.1 概述

​	链表（list）提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过赠删节点来灵活地调整链表的长度。



### 1.2.2 作用

- ​	列表的底层实现之一就是链表:

  ​             当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，redis就会使用链表作为列表键的底层实现

- 发布订阅

- 慢查询

- 监视器

- redis用链表来构建客户端输出缓冲区（output buffer ）



### 1.2.3 实现

```c
typedef struct listNode{
    //前置节点
    struct listNode *prev;
    
    //后置节点
    struct listNode *next;
    
    //节点的值
    void  * value;
    
}listNode;
```

```c
typedef struct list{
    //表头节点
    listNode *head;
    
    //后置节点
    listNode *tail;
    
    //链表所包含的节点数量
    unsigned long len;
    
    //节点值赋值函数
    void *(*dup)(void *ptr);
    
    //节点值释放函数
    void *(*free)(void *ptr);
    
    //节点值对比函数
    int  (*match)(void *ptr,void *key);
    
}list;
```

虽然仅仅使用多个listNode结构就可以组成链表，但使用list来持有链表，操作会更方便。

### 1.2.4 特性

- 双端
- 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。
- 可直接操作表头指针
- 可直接操作表尾指针
- 带链表长度计数器
- 多态：链表节点使用 void* 指针来保存节点值，并且可以通过list结构的 dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。







## 1.3 字典

### 1.3.1 概述

字典，又称为符号表（symbol table）、关联数组 （ associative array ）或映射（map）, 是一种用于保存键值对（key-value pair）的抽象数据结构。



哈希节点：键值对

哈希表：数组+链表  

字典：对哈希表进一步封装



### 1.3.2  作用

- **Redis的数据库就是使用字典来作为底层实现的**：对数据库的增、删、查、改操作也是构建在对字典的操作之上的，简单的说保存在redis的数据是以键值对的形式保存在名为“数据库”的字典里。
- **字典还是哈希键的底层实现之一**：当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现。



### 1.3.3 实现



![image-20200717223709385](img/image-20200717223709385.png)



哈希表

```c
typedef struct dictht{
    
    //哈希表数组
    dictEnty **table;
    
    //哈希表大小
    unsigned long size;
    
    //哈希表大小掩码，用于计算索引值 总是等于 size-1
    unsigned long sizemask;
    
    //该哈希表已有节点的数量
    unsigned long used;
    
}dictht;
```



table 属性是一个数组，数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针，每个dictEntry结构保存着一个键值对。



哈希表节点

```c
typedef struct dictEntry{
    
    //键
    void *key;
    
    //值
    union{
        void *val;
        uint64_tu64;
        int64_ts64;
    }v;
    
    //指向下个哈希表节点，形成链表
    struct dictEntry *next;
     
}dictEntry;
```



v属性保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数

next 属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，以此来解决键冲突（collision）的问题。



字典

```c
typedef struct dict{
    
    //类型特定函数
    dictType *type;
    
    //私有数据
    void *privdata;
    
    //哈希表
    dictht ht[2];
    
    //索引  当rehash 不在进行时，值为-1
    int rehashidx;
    
}dict;
```



type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的：

​		type 属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis 会为用途不同的字典设置不同的类型特定函数。

​		privdata属性则保存了需要传给哪些类型特定函数的可选参数。



```c
typedef struct dictType {
    
    //计算哈希值的函数
    unsigned  int (*hashFunction)(const void *key);
    
    //复制键的函数
    void *(keyDup)(void *privdata,const void *key);
    
    //复制值的函数
    void *(*valDup)(void *privdata,const void *obj);
    
    //对比键的函数
    int (*keyCompare)(void *privdata,const void *key1,const void *key2);
    
    //销毁键的函数
    void (*keyDestructor)(void *privdata,void *key);
    
    //销毁值的函数
    void (*valDestructor)(void *privdata,void *obj);
         
}dictType;
```



ht属性： ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会对ht[0]哈希表进行rehash时使用



rehash属性： 它记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为 -1。





### 1.3.4 rehash

为了让哈希表的负载因子（load factor） 维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。



扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成，Redis对字典的哈希表执行rehash的步骤如下：



#### 1.3.4.1 rehash步骤

1.  为字典的 ht[1] 哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是 ht[0].used属性的值）
   -   如果扩展，ht[1] 的大小为第一个大于等于ht[0].used*2 的2^n （2的n次方幂（mi））
   -   如果收缩，ht[1] 的大小为第一个小于等于ht[0].used的2^n.
2. 将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。
3. 当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0],将ht[1]设置为ht[0],并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。



#### 1.3.4.2 rehash触发条件

当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：

1. 服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于 1。
2. 服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于 5。

负载因子计算方式：

​	load_factor = ht[0].used / ht[0].size;



根据 BGSAVE 命令或 BGREWRITEAOF 命令是否正在执行，服务器执行扩展操作所需的负载因子并不相同，这是因为在执行 BGSAVE 命令或者 BGREWRITEAOF 命令的过程中，Redis 需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（ copy-on-write）技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。



另一方面，当哈希表的负载因子小于 0.1 时，程序自动开始对哈希表执行收缩操作。



####  1.3.4.3 渐进式rehash

扩展或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1]里面，但是，这个rehash动作并不是一次性完成的，而是分多次、渐进式地完成的。







## 1.4 跳跃表

有点难理解 ， 需要有懂的人，给予讲解



![image-20200720001135838](img/image-20200720001135838.png)



### 1.4.1  概述

跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。



跳跃表支持平均 O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。



在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。



### 1.4.2   作用

- 有序集合键的底层实现之一：如果一个有序集包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串时，Redis 就会使用跳跃表来作为有序集合键的底层实现。
- Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外，跳表在Redis里面没有其他用途。



### 1.4.3 实现

 Redis的跳跃表由 redis.h/zskiplistNode 和 redis.h/zskiplist 两个结构定义。

zskiplistNode 结构用于表示跳跃节点

zskiplist 结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表位节点的指针等等。



![image-20200720001408775](img/image-20200720001408775.png)



#### 1.4.3.1***跳跃表节点***

```c
typedef struct zskiplistNode {
    
    //层
    struct  zskiplistLevel{
        
        //前进指针
        struct  zskiplistNode *forward;
        
        //跨度
        unsigned int span;
        
	}level[];
    
    //后退指针
    struct zskiplistNode *backward;
    
    //分值
    double  score;
    
    //成员对象
    robj *obj;
    
}zskiplistNode;
```

**1.层**

跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。

每次创建一个新跳跃表节点的时候，程序都根据幂次定律（power law  ,越大的数出现的概率越小）随机生成一个介于1和32之间的值做为level数组的大小，这个大小就是层的“高度”。



**2.前进节点**

每个层都有一个指向表尾方向的前进指针（level[i].forward 属性），用于从表头向表尾方向访问节点。



**3.跨度**

层的跨度（level[i].span 属性）用于记录两个节点之间的距离：

- 两个节点之间的跨度越大，它们相距得就越远。
- 指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。



遍历操作只使用前进指针就可以完成，跨度实际上是用来计算排位（rank）的：

​	在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的

​    排位



**4.后退指针**

节点的后退指针（backwards ）用于表尾向表头方向访问节点：	

​	跟一次可以跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点





**5.分值和成员**

节点的分值（score）是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。



节点的成员对象（obj属性）是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值，



在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：

​	分值相同的节点将按照成员对象在字典序中的大小来进行排序，成员对象较小的节点会排在前面（靠近表头的的方向），而成员对象较大的节点则会排在后面（靠近表尾的方向）。



#### 1.4.3.2***跳跃表***

仅靠多个跳跃表节点就可以组成一个跳跃表

但通过一个zskiplist结构来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或者快速地获取跳跃表节点的数量（也既是跳跃表的长度）等信息。

```c
typedef struct zskiplist{
    
    //表头节点和表尾节点
    struct skiplistNode *header,*tail;
    
    //表中节点的数量
    unsigned long length;
    
    //表中层数最大的节点的层数
    int level;
    
}zskiplist;
```



header 指向跳跃表的表头

tail 指向表尾节点

length 记录节点的数量

level 属性则用于在O(1)复杂度内获取跳跃表中层高最大的那个节点的层数量，注意表头的层高并不计算在内。







## 1.5 整数集合

### 1.5.1概述

​	整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。



### 1.5.2 作用

- ​	整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。



### 1.5.3 实现

```c
typedef struct intset{

	//编码方式
	uint32_t encoding;
	
	//集合包含的元素数量
	uint32_t length;
	
	//保存元素的数组
	int8_t contents[];

}intset;
```



contents[ ]  数组是整数集合的底层实现： 整数集合的每个元素都是 contents数组的一个数组项（item）,各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项，存储内容的格式取决于 encoding。



length 属性记录了整数集合包含的元素数量，也即是 contents[] 数组的长度.



### 1.5.4 升级

 每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（ upgrade ）,然后才能将新元素添加到整数集合里面。





#### 1.5.4.1 步骤

- 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。
- 将底层数组现有的所有元素都转换成与新元类型相同类型，转换过程中有序性不变。
- 将新元素添加到底层数组里面。



#### 1.5.4.2 升级的好处  

1. 提升整数集合的灵活性：可以任意添加任何编码的整数 int_8  int_16  int_32  int_64。
2. 尽可能地节约内存。



### 1.5.5 降级

整数集合不支持降级操作



## 1.6 压缩列表

### 1.6.1概述

压缩列表 （ziplist）是列表键和哈希键的底层实现之一。



### 1.6.2 作用

- 列表键的底层实现之一：当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。
- 哈希键的底层实现之一：当一个哈希键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。



### 1.6.3 实现

压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。

一个压缩列表可以包含任意多个节点（entry）,每个节点可以保存一个字节数组或者一个整数值。



#### 1.6.3.1 压缩列表的构成

| 属性    | 类型     | 长度  | 用途                                                         |
| ------- | -------- | ----- | ------------------------------------------------------------ |
| zlbytes | uint32_t | 4字节 | 记录整个压缩列表占用的内存字节数; 在对压缩列表进行内存重分配，或者计算 zlend 的位置时使用 |
| zltail  | uint32_t | 4字节 | 记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址 |
| zllen   | uint16_t | 2字节 | 记录了压缩列表包含的节点数量：当这个属性的值小于UINT16_MAX（65535）时，这个属性的值就是压缩列表包含节点的数量：当这个值等于 UINT16_MAX时，节点的真实数量需要遍历整个压缩列表才能计算得出 |
| extryX  | 列表节点 | 不定  | 压缩列表包含的各个节点，节点的长度由节点保存的内容决定       |
| zlend   | uint8_t  | 1字节 | 特殊值 0xFF （十进制255)，用于标记压缩列表的末端             |



#### 1.6.3.2 压缩列表节点的构成

每个压缩列表节点可以保存一个字节数组或者一个整数值。



#### 1.6.3.3 连锁更新操作


添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率不高。







## 1.7 对象

### 1.7.1 概述

在前面的内容中，我们描述了Redis用到的所有主要数据结构，简单动态字符串，双端链表，字典，压缩列表，整数集合等等。



Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种我们前面所介绍的数据结构。



### 1.7.2 特性

- 通过不同类型的对象，Redis可以判断一个对象是否可以执行给定的命令。
- 可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。
- Redis对象实现了基于引用计数技术的内存回收机制。
- Redis还通过引用计数技术实现了对象共享机制，这个机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。
- Redis对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了 maxmemeory （最大存储）功能的情况下，空转时长比较大的哪些键可能会优先被服务器删除，



### 1.8.3  类型

Redis 使用对象来表示数据库中的键和值，每次当我们在Redis的数据中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。



Redis 中每个对象都由一个  redisObject 结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性：

```c
typedef struct redisObject{
	
    //类型
    unsigned type:4;
    
    //编码
    unsigned encoding:4;
    
    //指向底层实现数据结构的指针
    void *ptr;
    
    //...
	
}robj;
```



对象的type属性记录了对象的类型，这个属性的值可以是表 8-1 列出的常量的其中一个。

| 类型常量     |  对象的名称  |
| :----------- | :----------: |
| REDIS_STRING |  字符串对象  |
| REDIS_LIST   |   列表对象   |
| REDIS_HASH   |   哈希对象   |
| REDIS_SET    |   集合对象   |
| REDIS_ZSET   | 有序集合对象 |



对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是上述的五种对象。



### 1.8.4 编码和底层实现

对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。



encoding属性记录了对象所使用的编码，也既是说这个对象使用了什么数据结构作为对象的底层实现，这个属性的值可以是以下常量之一.



通过encoding 属性设定对象所使用的编码，极大地提升了Redis的灵活性和效率，以为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一个场景下的效率。





### 1.8.5 字符串对象

字符串对象的编码可以是int、raw 或者 embstr 。



- 保存整数值，并且这个整数值可以用long类型表示，那么字符串对象 的 encoding 是 int.
- 保存字符串长度大于32字节，那么字符串对象采用 SDS保存字符串值，encoding是 raw.
- 保存字符串长度小于等于32字节，那么字符串对象采用   embstr编码的简单动态字符串 保存字符串值，encoding是EMBSTR.



类型转换

- int编码的字符串对象，当其值不在是整数时，对象编码将由int转换成 raw.
- embstr编码的字符串，（由于embstr编码的字符串没有修改的方法，所以 embstr编码的字符串有修改操作时都最会变成 raw编码的字符串）



字符串相关命令  参考命令 模块。





### 1.8.6  列表对象

列表对象的编码可以是 ziplist 或者 linkedlist  .



编码类型

- ziplist编码的列表对象 使用**压缩列表**作为底层实现，每个压缩列表节点（entry）保存一个列表元素。
- linkedlist编码的列表对象使用**双端链表**作为底层实现，每个双端链表节点（node）都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素
- 字符串对象是Redis五种类型对象中唯一会被其他四种对象嵌套的对象。



编码转换

- 列表对象保存的所有字符串元素的长度都小于64字节，且保存的元素数量小于512个，则使用 ziplist编码
- 否则使用likedlist 编码

注意：上述值可以修改，在配置文件中 关注 list-max-ziplist-value 和 list-max-ziplist-entries选项



### 1.8.7 哈希对象

哈希对象的编码可以是ziplist或者hashtable



编码类型

- ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先保存键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾。
- hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存。
  - 字典的每个键都是一个字符串对象，保存键
  - 字典的每个值都是一个字符串对象，保存值



编码转换

- 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节，且数量小于512个，则使用ziplist编码。
- 否者使用 hashtable 编码。



注意: 配置文件中的 hash-max-ziplist-value 和 hash-max-ziplist-entries 选项 可以修改上述值。



### 1.8.8 集合对象

集合对象的编码可以是inset 或者 hashtable。



编码类型

- inset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。
- hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL (java中的set集合也是，map实现，值设置成Object)



编码转换

- 集合对象保存的所有元素都是整数值，保存的元素数量不操作512个时，使用 inset编码
- 否则使用hashtable编码



注意:

​	512个数量可以在配置文件中进行配置，具体看配置文件中关于 set-max-inset-entries选项的说明。



### 1.8.9 有序集合对象

有序集合对象的编码可以是 ziplist 或者 skiplist.



编码类型

- ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member）,而第二个元素则保存元素的分值（score）.
    - 压缩列表内的集合元素按分值从小到大进行排序，分值小的靠近表头，分值大的靠近表尾。
- skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：



```c
typedef struct zset{
	
    zskiplist  *zsl;
    
    dict *dict;
    
}zset;
```

具体内容参考   《Redis设计与实现》P216

注意：虽然zset结构同时使用跳跃表和字典来保存有序集合元素，但这两种数据结构都会通过指针来共享相同元素的成员和分支，所以使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，也不会因此而浪费额外的内存。  而且可以同时保有两种结构的特性。



编码转换

- 有序集合保存的元素数量小于128个，且所有元素成员的长度都小于64字节。
- 否则使用 skiplist。



注意：

​	以上两个条件的上限值是可以修改的，具体请看配置文件中关于 zset-max-ziplist-entries 选项

   和 zet-max-ziplist-value 选项的说明。





### 1.8.10  类型检查与命令多态



Redis中用于操作键的命令基本上可以分为两种类型。

- 一种可以对任何类型的键执行：例如, DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令等。
- 另一种命令只能对特定类型的键执行。



类型检查

在执行一个类型特定的命令之前，Redis会先检查输入键的类型是否正确，然后再决定是否执行给定的命令。

类型特定命令进行的类型检查是通过redisObject结构的type属性来实现的。



多态命令的实现

Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。

所以像 DEL、EXPIRE、TYPE等命令也称为多态命令，因此无论输入的键是什么类型，这些命令都可以正确地执行。



### 1.8.11 内存回收

因为C语言不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数（reference  counting）技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。



每个对象的引用计数信息由 redisObject结构的 refcount 属性记录：

```c
typedef struct redisObject{
	
    //...
    
    //引用计数
    int refcount;
    
    //...
    
}robj;
```



- 创建一个新对象时，引用计数的值会被初始化为1；
- 当对象被一个新程序使用时，它的引用计数值会被增一；
- 当对象不在被一个程序使用时，它的引用计数值会被减一；
- 当对象的引用计数值变为0时，对象所占用的内存会被释放；



疑问：TODO   如何检测到对象被引用？





### 1.8.12 对象共享

除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。



举个例子，假设键A创建了一个包含整数值100的字符串对象作为值对象。

如果这时键B也要创建一个同样保存了整数值100的字符串对象作为值对象，那么服务器有以下两种做法：

1 ) 为键B新建一个包含整数值100的字符串对象；

2 ）让键A和键B共享同一个字符串对象；



疑问：TODO  Redis如何知道要存储的值，已存在？



在Redis中，让多个键共享同一个值对象需要执行以下两个步骤：

- 将数据库键的值指针指向一个现有的值对象；
- 将被共享的值对象的引用技术增一；



目前来说，Redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了 从0 到 9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象

（作用有点类似 静态常量池的作用）



注意:

​	创建共享字符串对象的数量可以通过修改redis.h/REDIS_SHARED_INTEGERS 常量来修改。

​	（有一点，Redis只针对整数值具有这一特性，原因是，校验值特别费CPU）



### 1.8.13 对象的空转时长

除了前面介绍过的type、encoding、ptr和refcount四个属性之外，redisObject结构包含的最后一个属性为 lru 属性，该属性记录了对象最后一次被命令程序访问的时间：



```c
typedef struct redisObject{

	//...
	
	unsigned lru:22;
	
	//...

}robj;
```



OBJECT IDLETIME 命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的：



键的空转时长的作用：

- 被OBJECT IDLETIME 命令打印出来
- 如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为 volatile-lru 或者 allkeys-lru,那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。



配置文件的 maxmemory 选项 和 maxmemory-policy 选项的说明介绍了关于这方面的更多信息。



# 2.单机数据库的实现



## 2.1 数据库



### 2.1.1 概述

​	Redis服务器将所有数据库都保存在服务器状态 redis.h / redisServer 结构的db数组中，db数组的每个项都是一个redis.h / redisDb结构，每个redisDb结构代表一个数据库：

```c
struct redisServer {

	//...
	
	//一个数组，保存着服务器中所有数据库
	redisDb *db;
	
    //服务器的数据库数量
    int dbnum;
    
	//...

};
```



dbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16，所以Redis服务器默认会创建16个数据库。如下图：

![image-20200726185830107](img/image-20200726185830107.png)

P208

### 2.1.2 切换数据库

每个Redis客户端都有自己的目标数据库，每当客户端执行数据库写入命令或者数据库读命令的时候，目标数据库就会成为这些命令的操作对象。



默认情况下，Redis使用0号数据库，但可以通过执行SELECT命令来切换目标数据库。





```c
typedef struct redisClient{

	//...
	
	//记录客户端当前正在使用的数据库
	redisDb *db;
	
	//...

}redisClient;
```



redisClient.db 指针指向 redisServer.db 数组的其中一个元素，而被指向的元素就是客户端的目标数据库。



![image-20200726211133051](img/image-20200726211133051.png)



### 2.1.3 数据库键空间

#### 2.1.3.1 概述

Redis是一个键值对（key-value pair）数库服务器，服务器中的每个数据库都由一个redis.h / redisDb 结构表示，其中，redisDb 结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key  space）：

```c
typedef struct redisDb{

	//...
	
	//数据库键空间，保存着数据库中的所有键值对
	dict  *dict;
	
	//...

}redisDb;
```



键空间和用户所见的数据库是直接对应的：

- 键空间的键也就是数据库的键，每个键都是一个字符串对象
- 键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。



![image-20200726214912740](img/image-20200726214912740.png)



#### 2.1.3.2 添加新建

添加一个新建值对到数据库中，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis 对象。



#### 2.1.3.3 删除键

删除数据库中的一个键，实际上就是在键空间里面删除键所对应的键值对对象。

redis\>  DEL  键名



#### 2.1.3.4 更新键

对一个数据库键进行更新，实际上就是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。



#### 2.1.3.5 对键取值

对一个数据库进行取值，实际上就是在键空间中取出键所对应的值对像，根据值对象的类型不同，具体的取值方法也会有所不同。



#### 2.1.3.6 其他操作

很多针对数据本身的Redis命令，也是通过对键空间进行处理来完成的。

当使用 Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作。

详情可以参考 《Redis设计与实现》P264



### 2.1.4  键的生存时间或过期时间

#### 2.1.4.1 概述

通过EXPIRE 命令或者 PEXPIRE 命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间

（Time To Live,TTL）,在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键：



```redis
redis> set key value
OK
redis> EXPIRE key 5
(integer) 1
redis> GET key // 5秒之内
"value"
redis> GET key // 5秒之后
(nil)
```



注意：

​	SETEX 命令可以在设置一个字符串键的同时为键设置过期时间，但这个命令是一个类型限定的命令（只能用于字符串键），原理和 EXPIRE 命令设置过期时间的原理是完全一样的。



- 通过EXPIRE 命令或者 PEXPIRE 命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间
- 与EXPIRE命令和PEXPIRE命令类似，客户端可以通过EXPIREAT 或者 PEXPIREAT  命令，以秒或者毫秒的精度给数据库中的某个键设置过期时间（expire time）



过期时间是一个 UNIX  时间戳，当键的过期时间来领时，服务器就会自动从数据库中删除这个键：



TTL 命令和PTTL命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间，也就是，返回距离这个键被服务器自动删除还有多长时间：



#### 2.1.4.2 设置过期时间

Redis有四个不同的命令可以用于设置键的生存时间（键可以存在多久）或过期时间（键什么时候会被删除）：

- EXPIRE  \<key\>  \<ttl\>  命令用于将键key的生存时间设置为 ttl 秒
- PEXPIRE \<key\>  \<ttl\>  命令用于将键key的生存时间设置为 ttl毫秒
- EXPIREAT \<key\>  \<timestamp> 命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳
- PEXPIREAT \<key\>  \<timestamp> 命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳



注意：虽然有多种命令，但几个命令都是使用 PEXPIREAT 命令来实现的，最后都会转换成 PEXPIREAT  命令



#### 2.1.4.3 移除过期时间

PERSIST 命令可以移除一个键的过期时间：

```redis
PERSIST 键	
```



PRESIST 命令就是PEXPIREAT命令的反操作：

​	PERSIST命令在过期字典中查找给定的键，并解除键和值在过期字典中的关联



#### 2.1.4.4 保存过期时间

redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典；

- 过期字典的键是一个指针，这个指针指向键空间中的某个键对象（即是某个数据库键）
- 过期字典的值是一个 **long long** 类型的整数，这个整数保存了键所指向的数据库键的过期时间--------一个毫秒精度的UNIX时间戳。

```
typedef  struct redisDb {

	//...
	
	//键空间
	dict *dict;
	
	//过期字典，保存着键的过期时间
	dict *expires;
	
	//...

}
```

注意：在实际中键空间的键和过期字典的键都指向同一个键对象，所以不会出现任何重复对象，也不会浪费任何空间。



#### 2.1.4.5  计算并返回剩余生存时间

TTL 命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间：

```
TTL  键
PTTL 键
```



#### 2.1.4.6 过期键删除策略

- 定时删除：
    - 在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。
    - 缺点：
        - 耗费CPU时间，不适合内存不紧张CPU时间紧张的情况。
- 惰性删除
    - 放任不管，但在键空间中获取键时，都检查取得的键是否过期，如果过期就删除该键
    - 缺点：
        - 对内存不友好，不适合内存紧张的情况。
- 定期删除
    - 每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。
    - 难点：
        - 难以确定删除操作执行的时长和频率
        - 如果太频繁或执行时间太长，就会消耗过多的CPU时间
        - 如果太少或太短，就会浪费内存。
        - 因此，使用定期删除策略时，需要合理地设置删除操作的执行时长和执行频率

注意：Redis中使用 惰性删除 和 定期删除 的组合。



### 2.1.5 数据库通知



#### 2.1.5.1 概述

​	数据库通知是Redis 2.8 版本新增加的功能，这个功能可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。



```
//客户端如果获取0号数据库中针对message键执行的所有命令
SUBSCRIBE__keyspace@0__:message

//客户端如果获取0号数据库中所有执行DEL命令的键:
SUBSCRIBE__keyevent@0__:del
```



服务器配置的notify-keyspace-events选项决定了服务器所发送通知的类型：

- 想让服务器发送所有类型的键空间通知和键事件通知，可以将选项的值设置为AKE。
- 想让服务器发送所有类型的键空间通知，可以将选项的值设置为AK。
- 想让服务器发送所有类型的键事件通知，可以将选项的值设置为AE
- 想让服务器只发送和字符串键有关的键空间通知，可以将选项的值设置为K$
- 想让服务器只发送和列表键有关的键事件通知，可以将选项的值设置为EL.



关于数据库通知功能的详细用法，以及notify-keyspace-events选项的更多设置，Redis的官方文档已经做了很详细的介绍，这里不再赘述。





#### 2.1.5.2发送通知

发送数据库通知的功能是由notify.c/notifyKeyspaceEvent 函数实现的：

void  notifyKeyspaceEvent(int type,char *event,robj *key,int dbid);



type: 当前想要发送的通知的类型，程序根据这个值来判断通知是否就是服务器配置的 notify-keyspace-events选项所选定的通知类型，从而决定是否发送通知。

event: 事件名称

keys：产生事件的键

dbid：产生事件的数据库号码，

函数会根据type参数以及这三个参数来构建事件通知的内容，以及接收通知的频道名。



发送通知的具体实现思路 ： 参考 《redis设计与实现》P314



## 2.2 RDB持久化

### 2.2.1 概述

Redis是一个键值对数据库服务器，服务器中通常包含着任意个非空数据库，而每个非空数据库中有可以包含任意个键值对，为了方便起见，我们将服务器中的**非空数据库**以及它们的**键值对**统称为**数据库状态**。



因为Redis是内存数据库，它将自己的数据库状态存储在内存里面，所以如果不想办法将存储在内存中的数据库状态保存到磁盘里面，那么一旦服务器进场退出，服务器中的数据库状态也会消失不见。



为了解决这个问题，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。



RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中。



RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态。



因为RDB文件是保存在硬盘里面的，，所以即使Redis服务器进程退出，甚至运行Redis服务器的计算机停机，但只要RDB文件仍然存在，Redis服务器就可以用它来还原数据库状态。



### 2.2.2 RDB 文件的创建

生成RDB文件的命令

- SAVE          save命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进场阻塞期，服务器不能处理任何请求

- BGSAVE     BGsave命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求，但在

  ​					BGSAVE命令执行期间，服务器处理SAVE、BGSAVE、BGREWRITEAOF 三个命令的方式和平时有所不同。（SAVE命令

  ​                    会被拒绝，BGSAVE也会被拒绝，BGREWRITEAOF会在BGSAVE执行完毕后执行（如果BGREWRITEAOF先执行，

  ​                    BGSAVE会被拒绝））

创建 RDB 文件的实际工作由rdb.c/rdbSave 函数完成，save和bgsave 都是以不同的方式调用 rdbSave函数



### 2.2.3 RDB文件的载入

RDB载入工作是在服务器启动时自动执行的，所有 Redis没有专门用于载入RDB文件的命令，只要Redis在启动时检测到了RDB文件存在，它就会自动载入 RDB文件。

服务器在载入 RDB文件期间会一直处于阻塞状态。



注意：

​	因为AOF文件的更新频率通常比RDB文件的更新频率高，所以

- 如果服务器开启了AOF持久化功能，那么服务器会优先使用 AOF 文件来还原数据库状态
- 只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB还原数据库状态。



### 2.2.4 自动间隔性保存

P329



P322





TODO 待续 309





TODO 待续 P271





# 1.命令



## 1.1 字符串命令

1. set
2. get
3. append
4. incrbyfloat
5. incrby 
6. decrby
7. strlen
8. setRange
9. getRange



## 1.2 列表命令

1. LPSUH

   RPUSH 列表对象键名  值  值  值...

   

2. RPUSH

   RPUSH 列表对象键名  值  值  值...

   

3. LPOP

4. RPOP

5. LINDEX

6. LLEN

7. LINSERT

8. LREM

9. LTRIM

10. LSET





## 1.3 哈希命令

1. HSET

   HSET  哈希对象键名  键  值 

2. HGET

3. HEXISTS

4. HDEL

5. HLEN

6. HGETALL



## 1.4 集合命令

1. SADD             添加新元素 

2. SCARD            包含元素数量
3. SISMEMBER     sismember 判断元素是否存在
4. SMEMBERS      
5. SRANDMEMBER   随机返回一个元素
6. SPOP                      随机返回一个元素，并从集合中删除
7. SREM                 





## 1.5 有序集合对象

1. ZADD
2. ZCARD
3. ZCOUNT
4. ZRANGE
5. ZREVRANG
6. ZRANK
7. ZREVRANK
8. ZREM
9. ZSCORE





## 1.6  数据库命令

1.SELECT   数值

例如： Select 2                       //表示选择使用 2 号数据库



## 1.7 过期时间

### 1.设置过期时间

1. EXPIRE  键名  时长  

​    例如： EXPIRE key 5    //表示给 key 设置5秒过期时间

- EXPIRE  \<key\>  \<ttl\>  命令用于将键key的生存时间设置为 ttl 秒
- PEXPIRE \<key\>  \<ttl\>  命令用于将键key的生存时间设置为 ttl毫秒
- EXPIREAT \<key\>  \<timestamp> 命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳
- PEXPIREAT \<key\>  \<timestamp> 命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳



### 2. 移除过期时间 

PERSIST 键	



### 3.计算剩余过期时间

TTL 键

PTTL  键



## 1.8 RDB文件

### 1.8.1 SAVE

//等待直到RDB文件创建完毕

redis> save 

OK

### 1.8.2 BGSAVE

//派生子进程，并由子进程创建 RDB

redis>BGSAVE

Backgroud  saving  started





1.1 TYPE 命令   

​	TYPE 键名 



2.OBJECT ENCODING 键名

查看使用什么编码实现



3.OBJECT IDLETIME 键名

查看键的空转时长	